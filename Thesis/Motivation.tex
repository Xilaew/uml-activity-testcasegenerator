\chapter{Introduction}
Model-Based Engineering is a recent technology in the domain of electrical and software engineering. In Model-Based Engineering the specification of a system is developed as a model.
%The Unified Modelling Language (UML) offers a large set of Modelling Elements and Diagrams and is also extensible. 
%It can be used to describe almost everything. 
One can model very detailed and describe a system bit by bit. At the same time a simple diagram can give a quick and intuitive overview of the system. 
Nevertheless in practice creating a model of a system is an effort that needs to pay off in order to be economic. 
%modelling is not an end unto itself. 
One way to get a benefit from Model-Based Engineering is to use the model to automate other tasks in software development. One of those tasks is testing. In Model-Based Testing we try to verify an implementation against its specification that is given as a model. In this thesis we will develop an algorithm to automatically generate relevant test cases and even working unit test code from the model. We will focus on UML activities as input model and assume a C function as the implementation to be tested. Since it is not a trivial task to transform a UML activity into C++ unit test code we will split the task up into subtasks, specify the interfaces between the different steps, and give algorithms for each step. Due to its generic architecture our algorithm can be adopted for different input models, output languages, coverage criteria, and constraint specification languages by modification of only one or two of the subtasks.
\section{A Real World Problem at Airbus}
\begin{figure}
\label{fig:Act2Code+Tests}
\includegraphics[width=0.7\textwidth]{./pics/Activity2Code+Tests.png}
\caption{Example of an activity diagram and the generated C code and corresponding unit tests}
\end{figure}
At Airbus Buxtehude, Model-Based Engineering shall soon replace the traditional require-ment--driven engineering approach. There are some benefits that we hope to be able to realize with Model-Based Engineering. One benefit is the automatic generation of source code from the model. Another way to profit from Model-Based Engineering is to use the specification as a test model from which all unit test code for the software implementation could be derived. In Figure \ref{fig:Act2Code+Tests} we visualise the idea of using one activity diagram to generate both implementation code and unit test code from it. In the upper part there is a simple activity diagram and below on the left hand side we can see the code that could have been generated from the activity diagram. On the right hand side the unit test is shown containing two test functions. Each test function is testing one control flow path. \\
For modelling behaviour and control flow of C functions UML activities will be used. The company Atego\textsuperscript{\textregistered} already built a proprietary code generator for Airbus Buxtehude, which generates a folder structure, C source code files, and C header files from a UML model, and fills function bodies with code generated from UML activities. The fact that the code is generated, however, does not make it fault free. We still need to validate the generated code by unit tests. The task in this thesis is to demonstrate how engineers can be supported in building the unit tests for the generated code. We decided to automate the generation of C++ unit tests from UML activities.\\
%\subsection{Independence of Souce code and Testmodel}
It is common knowledge that, one should not generate both the source code and the unit test from the same model. The implementation model needs to be independent from the test model, otherwise one ends up testing the implementation against itself. That is not meaningful. %We need independence between the implementation and the corresponding unit tests.
%Writing the complete unit test code by hand is cumbersome. 
On the other hand, generating unit tests from a complete new model that is built independently from the model used for code generation imposes much work. The decision was to share the structure of the activity between code generation and test generation. While the code generation uses procedural C code snippets that are embedded in the model, the test generation only relies on embedded declarative OCL constraints. By using two different programming paradigms as input for code generation and test generation we assume the generated C implementation to be independent from the generated unit tests.


\section{Outline of this Thesis}
This thesis focuses on generating unit tests from UML activities with embedded OCL constraints. Our approach is based on mathematical programming to make the test model executable and automatically find useful test data to test the implementation. We put some emphasis on mixed--integer--non--linear arithmetic constraints and will evaluate the limits of state--of--the--art mathematical solver implementations.
\subsection{Model Transformations}
We transform a UML activity diagram into a rigorous, executable, mathematical program. We decided to use multiple subsequent model transformations to carry out this transformation stepwise. In Section \ref{sec:Normalisation} we will specify how the UML and OCL input is transformed to an intermediate representation. During this transformation we can check design rules and ensure properties of the intermediate representation that are necessary in subsequent steps. From this intermediate representation we perform a model--to--text transformation to a mathematical programming language (Section \ref{sec:atcg2Ampl}).
\subsection{Mathematical Programming}
In order to compute test data for the system under test we will use AMPL (\textbf{A} \textbf{M}athematical \textbf{P}rogramming \textbf{L}anguage). The activity diagram will be represented by arrays of variables and indexed collections of arithmetic constraints. In a data section for the model we can specify which control flow path within the activity we are interested in. From the computed solution to the mathematical program we obtain the test data for the unit tests. When building the mathematical program from the activity care needs to be taken that the semantics of the resulting model corresponds with the semantics the modeller originally had in mind. We support the user by automatically adding constraints that would be cumbersome to make them explicit.
\subsection{State--Of--The--Art Constraint Solver Implementations} 
A great advantage of a commonly used mathematical programming language is that there are industrial--strength solvers available. By running a state--of--the--art solver the constraint system will be solved for any possible path in the activity diagram. From the results of the constraint solver we obtain possible input arguments for the C function implementing the activity diagram. Also, all expected return values as well as values for class properties before and after the execution of the activity will be computed. Depending on the problem formulation a suitable solver needs to be selected. Not every solver can solve every mathematical program, and not every mathematical program is an instance of an easy--to--solve problem. An overview of the problems that are considered throughout this thesis can be found in Section \ref{sec:Maths}.
\subsection{Results}
A practical result of this thesis is an Eclipse plug-in automatically generating unit tests for activity diagrams. The plug-in comes with a set of example models. Each example is an instance of a different mathematical problem and thus needs another solver so that it can be solved successfully. Moreover, we performed an industrial case study using a model of the PAX-Call system in Airbus. We added the missing OCL constraints and successfully generated test cases for the largest activity diagram within the model.

%To be precice at airbus the decicion was to use UML Activities for modelling behavior and controll flow of C functions for embedded Systems. 
%Basically we want to harvest the benefits from Model Based Engineering by building tool support to generate a test suite for a C function. 
%The generated Test Suite should of course be complete according to some coverage criteria to be selected by the user. 
%And it needs to integrate with the currently used Modelling tools. 
%There is no use in having a Tool working with models when you can not use the models from your standard modelling environment but have to build new models. 

%\subsection{Behavioural Modelling}
%\subsection{Generating Unit Tests from Behavioural Model}
%Explain Model Based engineering at Airbus Buxtehude with Component structure of the software and code generation as well as Test generation from a Model.
%Give the short overview over the complete thesis

\section{Organization}
The rest of this thesis is organized in three chapters. In the chapter \nameref{chap:preliminaries} we will explain the assumed input language (Section \ref{sec:UML}), give an overview of the theory of mathematical programming and constraint programming (Section \ref{sec:Maths}), refer to related work (Section \ref{sec:RelatedWork}), and explain the mathematical programming language AMPL.\\
In the chapter \nameref{chap:testgeneration} we first give a short overview of the overall algorithm (Section \ref{sec:testgenerationOverview}) and then explain the five subsequent steps of the algorithm. Each of them can be viewed as model--to--model, model--to--text, or text--to--model transformation (Sections \ref{sec:Normalisation} - \ref{sec:testgenerationUnitTestSynthesis}. The last section (Section \ref{sec:testgenerationImplementation}) is about the implementation of the presented algorithm in an Eclipse plug-in.\\
The chapter \nameref{chap:evaluation} presents the example collection (Section \ref{sec:evaluationAcademicModels}) that has been tested with the implemented Eclipse plug-in and elaborates on the strengths of different solvers. Also the case study (Section \ref{sec:evaluationCaseStudy}) can be found in this fourth chapter. Finally, we will also sum up a few problems that could not be solved within this thesis (Section \ref{sec:evaluationLimitations}).