\documentclass[runningheads,a4paper]{llncs}%
%\documentclass[runningheads,a4paper]{article}%
%
\usepackage{amssymb}%
\setcounter{tocdepth}{3}%
\usepackage{graphicx}%
\usepackage{listings}
\usepackage{lstlangampl}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{pgfplots}
%
\usepackage{url}%
\urldef{\mailsa}\path|{felix.kurth, schupp}@tu-harburg.de|%
\newcommand{\keywords}[1]{\par\addvspace\baselineskip%
\noindent\keywordname\enspace\ignorespaces#1}%
%
% My user defined inclues%
\usepackage{color} %Makes incscape pdf_tex work%
\usepackage[T1]{fontenc} % makes Guillemont available%
\newcommand{\UMLType}[1]{\textsf{\textit{#1}}} %
\newcommand{\TCGType}[1]{#1}%
\newcommand{\UMLReference}[1]{\textsf{\textit{#1}}} %
\newcommand{\AMPLCode}[1]{\texttt{#1}}
\newcommand{\OCLCode}[1]{\texttt{#1}}
\newcommand{\AMPLListing}[1]{\begin{lstlisting}[basicstyle=\ttfamily\scriptsize,language=ampl]{#1}\end{lstlisting}}
%
\begin{document}%
%
\mainmatter  % start of an individual contribution%
%
% first the title is needed%
\title{Automated Generation of Unit Tests from UML Activity Diagrams using the AMPL Interface for Constraint Solvers}%
%
% a short form should be given in case it is too long for the running head%
\titlerunning{Automated Generation of Unit Tests}%
%
% the name(s) of the author(s) follow(s) next%
%
% NB: Chinese authors should write their first names(s) in front of%
% their surnames. This ensures that the names appear correctly in%
% the running heads and the author index.%
%
\author{Felix Kurth%
% \thanks{Please note that the LNCS Editorial assumes that all authors have used%
% the western naming convention, with given names preceding surnames. This determines%
% the structure of the names in the running heads and the author index.}%
\and Sibylle Schupp}%
%
%\authorrunning{Lecture Notes in Computer Science: Authors' Instructions}%
% (feature abused for this document to repeat the title also on left hand pages)%
%
% the affiliations are given next; don't give your e-mail address%
% unless you accept that it will be published%
\institute{Hamburg University of Technology, Institute for Software Systems,\\%
Schwarzenbergstr. 95, 21073 Hamburg, Germany\\%
\mailsa\\%
\url{http://sts.tu-harburg.de}}%
%
%
% NB: a more complex sample for affiliations and the mapping to the%
% corresponding authors can be found in the file "llncs.dem"%
% (search for the string "\mainmatter" where a contribution starts).%
% "llncs.dem" accompanies the document class "llncs.cls".%
%
%
%\toctitle{Lecture Notes in Computer Science}%
%\tocauthor{Authors' Instructions}%
\maketitle%
%
\begin{abstract}%
The task of Model--Based Testing is to ensure that the implementation behaves as specified in its model. We present a method to generate test data from UML activity diagrams. Our method uses symbolic execution to collect embedded OCL constraints along a control--flow path and transforms them into `\textbf{A} \textbf{M}athematical \textbf{P}rogramming \textbf{L}anguage' (AMPL). We derive test data from the mathematical program using state--of--the--art constraint solvers. The generated tests will satisfy control--flow--based coverage criteria on the used models. We also use boundary value analysis for testing. A special focus is on allowing mixed integer non--linear programming as well as logical formulas in OCL constraints. The presented method has been implemented in a demo Eclipse plug-in that generates fully automatically compilable C++ unit tests from activity diagrams.%
\keywords{Model-Based Testing, Activity Diagram, Constraint Solving, Mixed Integer Non--Linear Programming, Symbolic Execution, Boundary Value Analysis, Eclipse Plug-In}%
\end{abstract}%
\section{Introduction}%
Model--Based Engineering is a recent technology in the domain of electrical and software engineering. The Unified Modelling Language\textsuperscript{\texttrademark} (UML) is the quasi standard to build model--based specifications. A UML diagram can give a quick and intuitive overview of a system. At the same time, UML can be used as a formal modelling language to express details of the design and behaviour. The activity diagram is one of the behavioural diagrams specified in the UML. It can be used to describe a use case at the system level as well as to visualise the detailed control and data flow of a function. Activity diagrams also support hierarchical modelling whereby it is possible to start with a vague description of the intended use of a system and add more and more details until one models at the function level.\\%
Modelling is not an end unto itself. One way to profit from Model-Based Engineering is to automate other tasks in software development. One important task is testing. We want to generate test data fully automated from an activity diagram with embedded OCL constraints. The test model is a model of the relevant control--flows in the system under test (SUT). The embedded OCL constraints describe interdependencies between the variables and how variables change their value.\\
In this paper we present a transformation from an activity diagram into an `A Mathematical Programming Language' (AMPL) program. We symbolically execute control--flow paths in the activity diagram and encode each of them as AMPL program. The solution of the resulting AMPL program contains input values and corresponding oracle values that can be used to test the implementation. Since tests using test data at the bounds of path constraints have a higher probability to detect faults, we also use boundary value analysis. Depth--first search is used to find control--flow paths and we introduced \emph{early infeasible path elimination} within the depth--first search to reduce the runtime of our algorithm. The presented transformation is implemented as part of a master thesis \cite{Kurth2014AutomatedGen} in a proof--of--concept fully automated unit test generation tool. The tool is available as Eclipse plug-in \cite{PartegWebsite}.\\%
We will summarise Model--Based Testing approaches similar to ours in Section \ref{sec:LiteratureReview}. Definitions and a description of the expected test model is given in Section \ref{sec:TestModel}. An introduction to the AMPL system is given in Section \ref{sec:AMPL}. Section \ref{sec:Algorithm} will explain the core ideas of the proposed algorithm beginning with the transformation of a control--flow path into an AMPL program, then, explaining how boundary value analysis is done and, finally, how we can efficiently search for test scenarios. We provide a proof--of--concept tool and will report on a case study in Section \ref{sec:CaseStudy}. Finally, we give an outlook.%
\section{Literature Review}%
\label{sec:LiteratureReview}%
While it is very common to use state machines as the test model, less research is performed on generating tests from UML activity diagrams. Wang Linzhang et al. propose in \cite{Linzhang04GeneratingTestCasefromActivityGrayBoxMethod} a path--search--based method to find test scenarios in an activity diagram. They also claim to have implemented a proof--of--concept tool called UMLTGF, which, unfortunately, was unavailable for review. Another proposal using UML Activities as test model comes from Chen Minsong et al. \cite{mingsong2006automatic}. Their approach is to generate random executable unit tests for a Java implementation and match the execution traces of the randomly generated unit tests with the control--flow paths found in an activity diagram. They then select a subset from the test cases, which covers all simple paths in the test model.\\%
Stephan Wei{\ss}leder and Dehla Sokenou presented a data--oriented approach to select test cases \cite{weissleder2008automatic}. They propose to use abstract interpretation to derive partitions of the domain of input values. They then propose to select values at the boundaries of the computed partitions as test data. In Stephan Wei{\ss}leders Ph.D Thesis \cite{ParTeG} we found the most detailed and complete collection of different model--structure and data--oriented coverage criteria. Furthermore, a formal definition of the coverage criteria is given. The source code of ParTeG, the proof--of--concept tool associated with this thesis, is freely available. It uses graph search in combination with abstract interpretation and a comprehensive framework allowing the user to steer which coverage criteria the generated test cases will adhere to.\\%
Using OCL as input and trying to obtain test data by solving OCL constraints there have been several proposals on how exactly to find models that make an OCL formula true. Shaukat Ali et al. proposed in \cite{ali2011search} using evolutionary or genetic algorithms to search for potential solutions of OCL constraints. Matthias P. Krieger and Alexander Knapp proposed in \cite{krieger2008executingUnderspecifiedOCL} using a SAT solver to find instantiations of variables fulfilling OCL constraints. They suppose to transform OCL formulas into boolean formulas with bounded quantifiers and uninterpreted functions. Consequently, they use a model finder, based on a SAT solver, capable of handling those formulas to find assignments to the variables.\\%
In \cite{malburg2011combining} Jan Malburg and Gordon Fraser propose a hybrid approach. On the top level they use a genetic algorithm evolving a population of candidate test data. Internally, they provide guidance to the genetic algorithm by providing a special mutation operator performing dynamic symbolic execution. Also the white--box unit test tool PEX \cite{pex} from Microsoft\textsuperscript{\textregistered} research is based on dynamic symbolic execution. Both publications, \cite{malburg2011combining} and \cite{pex}, propose to execute the implementation with random input values and generate new input values by collecting all path conditions along the executed control--flow. Then they negate one of the path conditions and use a constraint solver to find a solution for the new constraint system. The generated solution yields new input data, which is guaranteed to take another control--flow path in the program.%
% \subsection{Overview}%
% \subsubsection{Symbolic Execution}
% In order to make UML activity diagrams executable for test data generation we will transform all relevant constraints embedded in the UML model into a mathematical program. Executing a certain control--flow path in the activity diagram means generating the corresponding mathematical program. The mathematical program will be stated in AMPL syntax. A mathematical program in AMPL consists of an AMPL model and AMPL data. One activity diagram will be transformed into one AMPL model and the currently executed control--flow path can be specified in the AMPL data.\\
% %In order to compute test data for the system under test we will use AMPL (\textbf{A} \textbf{M}athematical \textbf{P}rogramming \textbf{L}anguage). The activity diagram will be represented by arrays of variables and indexed collections of arithmetic constraints. In a data section for the model we can specify which control--flow path within the activity diagram we are interested in. From the computed solution to the mathematical program we obtain the test data for the unit tests. 
% When building the AMPL model from the activity diagram, we have to be careful that the semantics of the resulting AMPL model corresponds with the semantics the modeller originally had in mind. We support the user by automatically adding constraints that would be cumbersome to make explicit manually.
% \subsubsection{State--Of--The--Art Constraint Solver Implementations} 
% %We generate test data for a control--flow path in an activity diagram to be tested by having the corresponding AMPL program solved by a constraint solver. 
% A great advantage of a commonly used mathematical programming language is that industrial--strength solvers are available. The AMPL program corresponding to a possible control--flow path in the activity diagram will be solved with a state--of--the--art solver. Then we obtain test data from the results of the constraint solver. The generated test data includes possible input arguments for the C function that implements the activity diagram. Also, all expected return values as well as values for class properties before and after the execution of the activity diagram are included.\\
% A suitable solver needs to be selected depending on the problem formulation. Not every solver can solve every AMPL program, and not every AMPL program is an instance of an easy--to--solve problem. An overview of the problems that are considered throughout this thesis can be found in Section \ref{sec:Maths}.
% \subsubsection{Results}
% A practical result of this thesis is an Eclipse plug-in that automatically generates unit tests from activity diagrams. The plug-in comes with a set of example models. Each example is an instance of a different mathematical problem and thus needs an appropriate solver to be solved successfully. Moreover, we performed an industrial case study using a model of the PAX--Call system, which is part of an Airbus product. We added the missing OCL constraints and successfully generated test cases for the largest activity diagram within the model. Finally, we experimentally determined the scalability of the implementation.
% \section{Preliminaries}%
% \label{sec:Preliminaries}%
\section{Semantics of the Test Model}%
\label{sec:TestModel}%
For the transformation into `A Mathematical Programming Language' (AMPL) presented in Section \ref{sec:AMPLTransformation} we need to clarify the semantics of the expected input model. Whenever we refer to a modelling element such as \UMLType{Activity} we print it in a special font. References and attributes defined in the UML as, for example, \UMLReference{name} or \UMLReference{ownedParameter} are printed in a special font as well. In this section, we first clarify which UML modelling elements we use and will then shortly recapitulate the Petri--Net semantics of activity diagrams (see \cite{UML23Superstructure}) and introduce the notion of a \emph{state}, which will be relevant for our algorithm.\\%
As test model we assume an activity diagram with \UMLType{Action}s, \UMLType{ControlNode}s, and \UMLType{ControlFlow}s modelling the control--flow of an \UMLType{Operation}. The \UMLType{Activity} is linked as \UMLReference{method} to its specifying \UMLType{Operation}. Each \UMLType{Action} can contain several textual OCL constraints as \UMLReference{localPostcondition} and each \UMLType{ControlFlow} can hold a textual OCL constraint as \UMLReference{guard}. The textual OCL in the \UMLReference{guard} and \UMLReference{localPostcondition} will be parsed in the context of the specifying \UMLType{Operation}. That means the OCL constraints can access all \UMLReference{ownedAttribute}s of the \UMLType{Class} containing the specifying \UMLType{Operation}. Further, all \UMLReference{ownedParameter}s of the specifying \UMLType{Operation} can be referenced in the textual OCL. We interpret every \UMLType{Property} as variable that can change its value during the execution of an \UMLType{Action}. A \UMLType{Parameter} will be interpreted as a parameter that can not change its value during the execution of an \UMLType{Action}.\\%
When executing a control--flow path, we start with a token in the \UMLType{InitialNode}. We allow only one \UMLType{InitialNode} per \UMLType{Activity}. The token can move along an enabled \UMLType{ControlFlow}. A \UMLType{ControlFlow} is enabled when the OCL constraint in its \UMLReference{guard} evaluates to true. We say that an \UMLType{Action} is being executed when a token resides in the \UMLType{Action}.\\%
We refer to an assignment of all variables and parameters as \emph{state}. While the token resides in the \UMLType{InitialNode} there is an initial state. After each execution of an \UMLType{Action} the current state can change according to the OCL constraints contained in the \UMLType{Action}'s \UMLReference{localPostcondition}. An OCL constraint contained as \UMLType{localPostcondition} can specify a relation between the current state and the previous state. Consequently, the states are interconnected with each other via \UMLReference{localPostcondition}s. The set of all relations contained in \UMLType{localPostcondition}s can be seen as state transition function. For a \UMLType{ControlFlow} to be enabled the OCL constraint in its \UMLReference{guard} has to evaluate to true with respect to the current state. OCL constraints contained in a \UMLReference{guard} can only specify a relation between the variables and parameters within a single state. It is not possible to access the value of a variable in the previous state within a \UMLReference{guard}.%
\section{AMPL and its Solvers}%
\label{sec:AMPL}%
We use `A Mathematical Programming Language' (AMPL) by Robert Fourer \cite{AMPL} as a means to formalise the execution of a control--flow path in the test model. There is also a software that takes a program in the AMPL language and transforms it into a form that can be digested by constraint solvers. In this section, we will discuss the expressiveness of AMPL and introduce the solvers we have successfully used to generate test data.\\%
An AMPL program consists of two parts, the AMPL model and the AMPL data. In AMPL models we can declare parameters, sets, variables, and constraints. In the AMPL data we will give specific values for the parameters and sets. A suitable state--of--the--art solver can assign the variables such that all constraints are satisfied with the given parameters and sets.
\begin{table}%
\begin{center}%
\begin{tabular}{l r r r r r r r r}%
Solver                         & MILP       & NLP        & SMT        & MINLP\\%
\hline%
Cplex                          & \checkmark &            &            &\\%
LPsolve\cite{lpsolve}          & \checkmark &            &            &\\%
Gurobi                         &            & \checkmark &            &\\%
Minos                          &            & \checkmark &            &\\%
IlogCP\cite{ilogcp}            & \checkmark &            & \checkmark &\\%
GeCoDE\cite{gecode}            &            &            & \checkmark &\\%
Couenne\cite{Belotti09couenne} & \checkmark & \checkmark &            & \checkmark\\%
\hline%
\end{tabular}%
\end{center}%
\caption{List of solvers and problems they can solve.}%
\label{tab:Solvers}%
\end{table}\\%
In AMPL we can state linear constraints and non--linear constraints. Variables can be continuous or discrete; furthermore, AMPL provides logical operations. The AMPL system serves as a common interface to a variety of solvers. Depending on the constraint satisfaction problem encoded in the AMPL program a suitable solver can be selected to solve the problem. If all constraints are linear we use a solver that is specialized on mixed integer linear programming (MILP). If constraints are non--linear but convex and all variables are continuous we use a non--linear programming (NLP) solver. For problems with non--linear constraints and discrete as well as continuous variables we need a solver capable of solving mixed integer non--linear programming (MINLP). If logical operations are used in the constraints, a satisfiability modulo theories (SMT) solver supporting appropriate background theories is used. In Table \ref{tab:Solvers} we show a selection of solvers interfacing with AMPL. A checkmark in a cell means that we have successfully tested the solver in the row on the problem named in the column.%
\section{The Algorithm}%
\label{sec:Algorithm}%
In this section we explain the core ideas of the algorithm that is implemented in the tool available from \cite{PartegWebsite}. First, we demonstrate with a small example how the execution of a control--flow path can be formalised. Then we show how to acquire test data that is at the boundary of path constraints and, finally, we present an algorithm that searches for testable control--flow paths efficiently.%
\subsection{AMPL Transformation}%
\label{sec:AMPLTransformation}%
\begin{figure}%
\def\svgwidth{\textwidth}%
\graphicspath{{./pics/}}%
\input{./pics/AssignmentDecision.pdf_tex}%
\caption{A simple UML activity diagram}%
\label{fig:AssignmentDecision}%
\end{figure}%
An AMPL model encodes the relevant variables, parameters, and OCL constraints contained in an activity diagram. We call a sequence of \UMLReference{ControlFlow}s \emph{control--flow path}. For two subsequent \UMLType{ControlFlow}s A and B in a control--flow path the constraint A.target=B.source holds. A control--flow path is encoded in the AMPL data. The activity diagram in Figure \ref{fig:AssignmentDecision} will serve as an example.\\%
We model the execution of a control--flow path as a series of states. Each AMPL model has one parameter called \AMPLCode{pathlength} representing the number of \UMLType{Actions} on a control--flow path. The state always changes during the execution of an \UMLType{Action}, consequently, there is one initial state and one post state after each execution of an \UMLType{Action}. Since a variable can have a distinct value in each state, each variable will be modelled in AMPL as an array of variables with the length $\AMPLCode{pathlength}+1$. Parameters are constant and cannot change their value from one state to another and will, consequently, be represented by a single AMPL variable. Every variable and parameter has one out of three possible types: integer, real, and boolean; In AMPL we specify the domain of an AMPL variable correspondingly.\\%
The OCL constraints in Figure \ref{fig:AssignmentDecision} reference three different OCL variables. We assume $a$ and $returnValue$ to be parameters that are modelled as a single variable in AMPL and we assume $x$ to be a variable that is modelled as an array of variables. We further assume that the \UMLReference{type} of the modelling elements corresponding to the OCL variables $a$, ${returnValue}$, and $x$ is integer. Consequently, we generate the following AMPL code for them: %
\begin{lstlisting}[basicstyle=\ttfamily,language=ampl]
param pathlength;
var a : integer;
var returnValue : integer;
var x{0..pathlength} : integer;
\end{lstlisting}%
The underlying MOF Model--to--Text Transformation Language (MOFM2T) template \cite{m2t.standard}, generating AMPL code from a \UMLType{Parameter} or \UMLType{Property} is shown in Algorithm \ref{alg:m2tvariable}.
\begin{algorithm}
\begin{lstlisting}[escapeinside={@}{@},breaklines=true]
[@\bfseries{template}@ public VariableToAMPL(var : @\UMLType{TypedElement}@)]
  [@\bfseries{let}@ type : @\UMLType{PrimitiveType} = var.type@]
    var [var.name/] [@\bfseries{if}@ var.oclIsKindOf(@\UMLType{Property}@)] {0..pathlength} [/@\bfseries{if}@][Type2AMPL(type)/] :=1;
  [/@\bfseries{let}@]
[/@\bfseries{template}@]

[@\bfseries{template}@ public Type2AMPL(type : @\UMLType{PrimitiveType}@)]
  [@\bfseries{if}@ type.name = 'integer'] : integer >=-10000, <= 10000 [/@\bfseries{if}@]
  [@\bfseries{if}@ type.name = 'boolean'] in 0..1 [/@\bfseries{if}@]
  [@\bfseries{if}@ type.name = 'real'] >=-10000, <= 10000 [/@\bfseries{if}@]
[/@\bfseries{template}@]
\end{lstlisting}%
\caption{Model--to--text transformation from \UMLType{Property} or \UMLType{Parameter} to AMPL model}%
\label{alg:m2tvariable}%
\end{algorithm}\\%
During execution, a \UMLType{ControlFlow}'s \UMLReference{guard} or an \UMLType{Action}'s \UMLReference{localPostcondition} is always evaluated with respect to the current state. The set of states in which an \UMLType{Action} or \UMLType{ControlFlow} is executed is called \emph{activation set}. There is one activation set for each \UMLType{ControlFlow} with an OCL \UMLReference{guard} and each \UMLType{Action} with OCL \UMLReference{localPostcondition}. All OCL post--conditions and OCL guards are contained in the AMPL model as constraints, which can be switched on and off for each state. %
In the AMPL model states are referenced via their index. For each \UMLType{Action} and \UMLType{ControlFlow} the activation set is declared as a subset of the set $\left[0..\texttt{pathlength}\right]$. Each OCL constraint in a \UMLReference{guard} or \UMLReference{localPostcondition} is transformed into an indexed collection of constraints over the activation set.\\
If the variable reference was marked with \verb=@pre= we are accessing the variable in the previous state and thus need to subtract one from the index; otherwise we access the variable at the index from the activation set. The value of the parameter \AMPLCode{pathlength} as well as the elements of each activation set will be specified in the AMPL data. This way, there is one AMPL model per activity diagram and any control--flow path within the activity diagram can be specified in the AMPL data. The AMPL model code generated for the Assignment \UMLType{Action} in Figure \ref{fig:AssignmentDecision} is, for example, as follows:%
\begin{lstlisting}[basicstyle=\ttfamily,language=ampl,breaklines=true]
set Assignment within {0..pathlength} default {};
s.t. Assignment_post0 {i in Assignment} : a*x[i]=2*x[i-1]*x[i-1]-3;
\end{lstlisting}
To illustrate how the symbolic execution of a control--flow path in an activity diagram is done we consider again the activity diagram in Figure \ref{fig:AssignmentDecision}. Let us assume we want to generate test data to test the control--flow path printed in bold, which executes the Assignment and the Then \UMLType{Action}. We start at the \UMLType{InitialNode}, the current state is the initial state with the index $0$. In this state there are no constraints. When we reach the Assignment \UMLType{Action} our current state switches to $1$. Since there is a post--condition for Assignment we add 1 to the activation set of the Assignment. The next \UMLType{ControlFlow} has an OCL guard, consequently we add $1$ to its activation set. Further, we add $2$ to the activation set of the Then \UMLType{Action}.\\%
In AMPL syntax, the data specifying this path is:%
\begin{lstlisting}[basicstyle=\ttfamily,language=ampl]
param pathlength := 2;
set Assignment := 1;
set Cf_Then := 1;
set Then := 2;
\end{lstlisting}%
The transformation from a sequence of \UMLType{ControlFlow}s into a map of activation sets is given in Algorithm \ref{alg:ActivationSet}.%
\begin{algorithm}
\begin{algorithmic}
\Require path := sequence of \UMLType{ControlFlow}s
\Ensure activationSets contains activation sets representing the given path
\State activationSets(element : \UMLType{NamedElement}) : Integer Set \Comment Mapping from an UML element to a set of integers. Initially all sets are empty.
\State i $\gets$ 0 \Comment index of the current state
\ForAll{cf : \UMLType{ControlFlow} $\in$ path}
\If{ cf.guard != null}
\State activationSet(cf).add(i)
\EndIf
\If{ cf.target.oclIsKindOf(\UMLType{Action}) }
\State i $\gets$ i+1 \Comment state changes
\State activationSet(cf.target).add(i)
\EndIf
\EndFor
\end{algorithmic}
\caption{Transformation from a control--flow path to a map of activation sets}
\label{alg:ActivationSet}
\end{algorithm}%
\subsection{Boundary Value Analysis}%
\label{sec:BoundaryValueAnalysis}%
Test data at the boundaries of the path constraints is more valuable than arbitrary test data causing the given control--flow path to be executed. We will refer to test data at the boundaries of path constraints also as \emph{boundary test data}. Up to now we have shown how we generate an AMPL program whose solutions can be used as test data for a given control--flow path. Now we want this test data to be boundary test data. Therefore, we add a linear objective function to the AMPL model. When solving AMPL programs augmented by such an objective function three things can happen: either the solver generates boundary test data, or the solver reports that the problem is unbounded, or the solving time for the problem increases enormously and the solver exceeds its time limit. The first case is the good case. In the second case we can change the direction of the objective function and try again to hit a boundary. The last case is especially a problem of mixed integer non--linear programming solvers. It is not too hard to find a solution to a mixed integer non--linear program, if there are enough solutions, but finding a solution that is optimal with respect to an objective function is much harder. In fact the solvers will try to find the global optimum although also a locally optimal solution with respect to a linear objective function would be suitable as boundary test data. In such a case we can first use a global mixed integer non--linear programming solver to solve the original AMPL program. In a second step we add the linear objective function and use a local search algorithm using the solution generated before as starting point to find a solution at the boundary of the path constraints.
\subsection{Early Infeasible Path Elimination}%
\label{sec:InfeasiblePathElimination}%
To identify the control--flow paths to generate test data for we construct a \emph{path tree}. A path tree is a tree data structure consisting of path tree nodes. Each path tree node holds a reference to its parent path--tree node and a reference to a \UMLType{ControlFlow}. The root node of a path tree points to an \UMLReference{outgoing} \UMLType{ControlFlow} of the \UMLType{InitialNode}. Any path tree node is a representation of a control--flow path from the \UMLType{InitialNode} to the \UMLReference{target} of the \UMLType{ControlFlow} referenced by that path tree node. Any leaf path tree node points to a \UMLType{ControlFlow} that ends in an \UMLType{ActivityNode} with no \UMLReference{outgoing} \UMLType{ControlFlow}. We call the control--flow path represented by a leaf path tree node an \emph{abstract test case}.\\
Not every control--flow path within an activity diagram is a \emph{feasible path}. A control--flow path is a feasible path, if it is possible to find test data that causes this control--flow path to be executed. In other words, for an infeasible path the corresponding AMPL program will contain contradicting constraints, for example: $x_0\leq5; x_0\geq10$. It is quite obvious, that if a path tree node represents an infeasible path any of its children nodes will also represent an infeasible path. Since we are only interested in abstract test cases for which test data can be generated we do not want to generate path tree nodes representing infeasible paths.\\
We can check whether the control--flow path represented by a path tree node is feasible by transforming it into an AMPL program as described in Section \ref{sec:AMPLTransformation} and running a solver. If the solver reports a failure or infeasibility of a problem, we assume the control--flow path to be infeasible. The earlier during construction of the path tree a control--flow path is detected to be infeasible the larger is the portion of the path tree that will not be examined further. On the other hand, if we check for every single path tree node during construction whether it is feasible we will impose unnecessary work. We allow for a customised trade--off by introducing the parameter \emph{unchecked steps}.%
\begin{algorithm}%
\begin{algorithmic}%
\Require activity := A UML \UMLType{Activity} \\
MaxDepth := maximum path length for each control--flow path \\
MaxNoPaths := maximum amount of different control--flow paths to be found\\
UncheckedSteps := 
\Ensure abstractTestCases := set of at most MaxNoPaths abstract test cases consisting of at most MaxDepth \UMLType{ControlFlow}s each\\
\State abstractTestCases $\gets$ initially empty set of path tree nodes \Comment initialisation
\State stack $\gets$ initially empty stack of path tree nodes
\State push root path tree node to stack
\While{!queue.isEmpty() \textbf {and} abstractTestCases.size $\leq$ MaxNoPaths}
\State ptNode $\gets$ stack.pop() \Comment visit next path tree node from the queue
\If{ptNode.depth $\leq$ MaxDepth} \label{line:BFSifFeasible}\Comment search only up to MaxDepth
\For{cf : \UMLType{ControlFlow} $\in$ ptNode.controlFlow.target.outgoing}
\State stack.push(new PathTreeNode(cf, ptNode.depth + 1, ptNode)) \Comment Add successor nodes to queue
\EndFor
\EndIf
\If{ptNode.controlFlow.target.outgoing->size()=0} \Comment A final node has been found
\State abstractTestCases.add(ptNode)
\EndIf
\EndWhile
\end{algorithmic}
\caption{Depth--first search based algorithm with early infeasible path elimination}
\label{alg:BreadthFirstSearch}
\end{algorithm}%
\section{Results}%
\subsection{Proof--of--Concept Tool}%
\label{sec:EclipsePlugIn}%
\section{Case Study}%
\label{sec:CaseStudy}
We tested our implementation on a model modelling the PAX call system from Airbus Operations GmbH. Out of the model of the complete product we selected a large activity diagram. The selected \UMLType{Activity} contains 21 \UMLType{Actions}, 24 \UMLType{ControlNodes}, and two \UMLType{LoopNodes}. Furthermore, there are eight \UMLType{DataStoreNodes} representing function local variables. The branching conditions and the code body of each \UMLType{Action} is given in C syntax. All assignments and conditions consist of linear equations and inequalities only. All variables are in the integer or boolean domain. Consequently, the constraint satisfaction problem to be solved for test data generation is a mixed integer linear program. The solvers Cplex and LPsolve are perfectly suitable for this kind of problem. Couenne can also be used for this task.\\
The described algorithm has several parameters. We use this case study to evaluate the influence of those parameters on the runtime. The examined parameters are the maximum length of control flow paths, the maximum amount of test cases to be generated, the unchecked steps before an early infeasible path check is performed during the depth--first search, and the solver to use.
\subsection{Manual Adaptation}
In order to generate C++ unit test code with our Eclipse plug-in from the described model some pre--processing needs to be performed manually. We need to add all guards and the local post--conditions in OCL syntax, flatten the \UMLType{LoopNodes}, and replace the \UMLType{DataStoreNodes} by \UMLType{Properties}.\\
The model was provided as XMI export from Atego\textsuperscript{\textregistered} Artisan Studio. Each modelling tool uses its own implementation of the UML meta model. Due to slight differences in the implementations it is not simply possible to load an XMI file from Atego\textsuperscript{\textregistered} in Eclipse. We manually removed some objects not recognised by Eclipse and correct some typing errors in the XMI file. Then we could load the XMI file and browse the model with the Eclipse Modelling Framework.\\
Every \UMLType{Action} and \UMLReference{ControlFlow} contains C code snippets. There are not yet textual OCL constraints. We make an educated guess to add \UMLReference{guards} and \UMLReference{localPostconditions} reproducing the semantics of the C code snippets contained in the original model. The original model used local C struct variables modelled by the \UMLType{DataStoreNodes} contained by the \UMLType{Activity}. Our implementation can handle primitive data type variables modelled by \UMLType{Property} element. Consequently, we created one \UMLType{Property} per field of a struct variable. The original model also used arrays. We emulated the behaviour of an indexed collection by allowing all variables depending on an index to change to an arbitrary value whenever the index is changed. This may produce wrong behaviour but seemed fair enough to evaluate the runtime of our algorithm.\\
The \UMLType{LoopNodes} contain further model elements in their \UMLReference{bodyPart}. Those elements from the \UMLReference{bodyPart} are directly included into the parent \UMLType{Activity}. The \UMLType{InitialNode} and \UMLType{FinalNodes} of the loop body are replaced by decision nodes and directly connected to every element that was connected to the \UMLType{LoopNode}. In order to preserve the loop semantics additional \UMLType{ControlFlow}s, \UMLType{DecisionNode}s, and counter incrementing \UMLType{Action}s are added.\\
The function specifying which \UMLType{ControlFlow} to take after each \UMLType{Action} is well--defined and defined over the complete domain. 
% XXX resume here
%Well--defined means there is no possible state in which more than one \UMLReference{guard} evaluates to true, and defined over the complete domain means that there is no value assignment for which every \UMLReference{guard} of the \UMLReference{outgoing} \UMLType{ControlFlow}s evaluate to false.
\subsection{Runtime Measurement Results}
%The implemented algorithm has several properties influencing the exact execution of the \nameref{sec:pathsearch}. 
We examine the influence of the used solver, the maximum path length, and the maximum number of test cases on the runtime of our algorithm. The expected effects of those parameters on the overall runtime have already been discussed in Section \ref{sec:evaluationRuntimeMeasurement}.
\subsubsection{Different Solvers}
\begin{figure}
\begin{tikzpicture}
\begin{axis}[
width=0.59\textwidth,
height=10cm,
%legend columns=-1,
%legend to name=solvers,
legend style={at={(0.02,0.98)},anchor=north west},
xlabel={maximum path length},
ylabel={time $[s]$},
yticklabels={0,{$1$},{$10$},{$100$},{$10^3$},{$10^4$},{$10^5$}},
extra y ticks={3.6e12,2.592e14},
extra y tick labels={{1h},{3d}},
extra tick style={
        major grid style=black,
        tick align=outside,
        tick style=black
    },
minor x tick num=1,
xmin=15,
xmax=115,
ymax=1e14,
ymajorgrids=true,
yminorgrids=true,
xmajorgrids=true,
xminorgrids=true,
ymode=log,
]
\addplot[loosely dashed] table[x=PATHSEARCH_MAX_PATHLENGTH,y=time(ns)] {../Thesis/Experiment-DATA/CaseStudyRuntimeCplex.csv};
\addlegendentry{Cplex};
\addplot[dash pattern=on 7pt off 4pt] table[x=PATHSEARCH_MAX_PATHLENGTH,y=time(ns)] {../Thesis/Experiment-DATA/CaseStudyRuntimeLPSolve.csv};
\addlegendentry{LPsolve};
\addplot[densely dashed] table[x=PATHSEARCH_MAX_PATHLENGTH,y=time(ns)] {../Thesis/Experiment-DATA/CaseStudyRuntimeCouenne.csv};
\addlegendentry{Couenne};
\addplot[densely dotted] table[x=PATHSEARCH_MAX_PATHLENGTH,y=time(ns)] {../Thesis/Experiment-DATA/CaseStudyRuntimeGecode.csv};
\addlegendentry{GeCoDE};
\addplot[solid] expression[no markers, domain=30:110]{2e7*1.12^(x)} node[pos=0.5,sloped,fill=white, below, opacity=1,text opacity=1] {$1.12 ^ {x}$} ;
\end{axis}
\end{tikzpicture}
\begin{tikzpicture}
\begin{axis}[
width=0.39\textwidth,
height=8cm,
ylabel={number of test cases},
xlabel={maximum path length},
minor x tick num=4,
ymajorgrids=true,
yminorgrids=true,
xmajorgrids=true,
xminorgrids=true,
ymode=log,
]
\addplot[solid,mark=x] table[x=PATHSEARCH_MAX_PATHLENGTH,y=PathsFound]{../Thesis/Experiment-DATA/CaseStudyRuntimeLPSolve.csv};
\addplot[color=black, style=dashed] expression[no markers, domain=30:100]{1.1 ^ (x)} 
node[pos=0.5,sloped,fill=white, below, opacity=1,text opacity=1] {$1.1 ^ {x}$}
;
\end{axis}
\end{tikzpicture}
%\end{center}
\caption{Runtime of our algorithm applied to the case study. We measured the runtime with different solvers and varied the maximum path length. The runtime as well as the amount of test cases grow exponentially with the maximum path length.}
\label{fig:RuntimeExperimentsSolvers}
\end{figure}
We plotted the runtime depending on the maximum path length on the left hand side of Figure \ref{fig:RuntimeExperimentsSolvers}. We performed this experiment with different solvers. For \nameref{sec:pathsearch} the depth first search with early infeasible path elimination and two unchecked steps has been used. As we see, LPsolve Cplex and GeCoDE are equally fast. Using Couenne and a maximum path length of 60, our algorithm takes round about three times the runtime consumed using LPsolve and twice the runtime consumed with Cplex. Keep in mind that the plot is logarithmic. This might be because Couenne is actually suitable for the much more general mathematical problem of mixed integer non--linear programming; it is not perfectly specialized for mixed integer linear programming. To evaluate the slope of the exponential growth we also plotted the function $A\cdot1.2^x$. The runtime grows almost perfectly exponential with the maximum path length and the runtime doubles when the maximum path length increases by $6$-$7$. With a closer look at the graph, we can see that it is slightly super--exponential. This might be caused by effects that are inherent to the computing architecture executing the implementation of our algorithm.\\
The case study model contains only constraints that are instances of MILP and, therefore, the solvers always succeed to find the solution when there is suitable test data for a certain path. Consequently, our algorithm will produce all test cases up to the given path length no matter which solver is used. The number of test cases grows equally exponential with the maximum path length as the runtime. We plotted the number of test cases depending on the maximum path length on the right of Figure \ref{fig:RuntimeExperimentsSolvers}. This plot is also logarithmically scaled. 
\subsubsection{Unchecked Steps}
\begin{figure}
\begin{center}
\begin{tikzpicture}
\begin{axis}[
width=0.6\textwidth,
height=7cm,
legend style={legend columns=1,at={(1.02,0.98)},anchor=north west},
xlabel={unchecked steps},
xmax=15,
ylabel={time $[s]$},
yticklabels={{$1$},{$10$},{$100$},{$10^3$},{$10^4$},{$10^5$}},
extra y ticks={3.6e12,2.592e14},
extra y tick labels={{1h},{3d}},
extra tick style={
        major grid style=black,
        tick align=outside,
        tick style=black
    },
minor x tick num=1,
ymajorgrids=true,
yminorgrids=true,
xmajorgrids=true,
xminorgrids=true,
ymode=log,
]
\addlegendimage{empty legend}
\addlegendentry{maximum path length}
\addplot[dash pattern=on 4pt off 2pt on 1pt off 2pt] table[x=PATHSEARCH_UNCHECKED_STEPS,y=time(ns)]{../Thesis/Experiment-DATA/CaseStudyUncheckedSteps90.csv};
\addlegendentry{90};
\addplot[dash pattern=on 7pt off 2 on 1 off 2] table[x=PATHSEARCH_UNCHECKED_STEPS,y=time(ns)]{../Thesis/Experiment-DATA/CaseStudyUncheckedSteps80.csv};
\addlegendentry{80};
\addplot[dash pattern=on 7pt off 3pt] table[x=PATHSEARCH_UNCHECKED_STEPS,y=time(ns);]{../Thesis/Experiment-DATA/CaseStudyUncheckedSteps70.csv};
\addlegendentry{70};
\addplot[densely dashed] table[x=PATHSEARCH_UNCHECKED_STEPS,y=time(ns);]{../Thesis/Experiment-DATA/CaseStudyUncheckedSteps60.csv};
\addlegendentry{60};
\addplot[loosely dashed] table[x=PATHSEARCH_UNCHECKED_STEPS,y=time(ns)]{../Thesis/Experiment-DATA/CaseStudyUncheckedSteps50.csv};
\addlegendentry{50};\addplot[solid] table[x=PATHSEARCH_UNCHECKED_STEPS,y={time(ns)}]{../Thesis/Experiment-DATA/CaseStudyUncheckedSteps40.csv};
\addlegendentry{40};
\end{axis}
\end{tikzpicture}
\end{center}
\caption{Runtime of our implementation depending on the unchecked steps. The experiment has been performed with depth first search and Cplex as solver for different maximum path lengths}
\label{fig:RuntimeUncheckedSteps}
\end{figure}
In Figure \ref{fig:RuntimeUncheckedSteps}, we plotted the overall runtime of our algorithm depending on the unchecked steps of the early infeasible path elimination. We used Cplex as solver for this experiment and repeated the experiment for different maximum path lengths. In the plots we see, up to a maximum path length of 50 it is not beneficial to use early infeasible path elimination when generating test cases for the case study model. With longer maximum path lengths the impact of well configured early infeasible path elimination grows. For a maximum path length of 90 our algorithm configured with the optimal value for the unchecked steps parameter takes less than one hour to generate all test cases, while it takes several days when unchecked steps is set to 5 or 6.
\subsubsection{Maximum Amount of Test Cases}
\begin{figure}
\begin{tikzpicture}
\begin{axis}[
width=0.49\textwidth,
height=9cm,
xlabel={number of test cases},
ylabel={time $[s]$},
scaled y ticks = false,
% xtick scale label code/.code={\xdef\xtickscale{#1}}, 
yticklabels={0,{$1$},{$10$},{$100$},{$10^3$},{$10^4$},{$10^5$}},
extra y ticks={3.6e12,2.592e14},
extra y tick labels={{1h},{3d}},
extra tick style={
        major grid style=black,
        tick align=outside,
        tick style=black
    },
minor x tick num=1,
ymajorgrids=true,
yminorgrids=true,
xmajorgrids=true,
xminorgrids=true,
ymode=log,
xmode=log,
] 
\addplot[solid,mark=x] table[x=PathsFound,y=time(ns)]{../Thesis/Experiment-DATA/CaseStudyRuntimeLPSolve.csv};
\addplot[color=black, style=dashed] expression[no markers, domain=1e2:1e5]{(2e7) * x}
node [pos=0.7,below,sloped,fill=white,opacity=0.85,text opacity=1] {$x^1$} 
;
\addplot[color=black, style=dashed] expression[no markers, domain=1e2:1e5]{(4e6) * x ^ (1.45)} 
node [pos=0.9,sloped,above,fill=white,opacity=0.85,text opacity=1] {$x^{1.45}$} 
;
\addplot[color=black, style=dashed] expression[no markers, domain=1e2:1e4]{(6e5) * x ^ (2)} 
node [pos=0.7,sloped,above,fill=white,opacity=0.85,text opacity=1] {$x^{2}$} 
;
\end{axis}
\end{tikzpicture}
\begin{tikzpicture}
\begin{axis}[
width=0.49\textwidth,
height=9cm,
xlabel={number of test cases},
ylabel={time $[s]$},
scaled y ticks = false,
% xtick scale label code/.code={\xdef\xtickscale{#1}}, 
%xtick scale label code/.code={$10^3$}, 
%xtick scale label code/.code={\xdef\xtickscale{#1}},
yticklabels={{0},{0},{$2\cdot 10^{3}$},{ },{$6\cdot 10^{3}$},{$8\cdot 10^{3}$}},
extra y ticks={3.6e12,2.592e14},
extra y tick labels={{1h},{3d}},
extra tick style={
        major grid style=black,
        tick align=outside,
        tick style=black
    },
minor x tick num=1,
minor y tick num=4,
ymajorgrids=true,
yminorgrids=true,
xmajorgrids=true,
xminorgrids=true,
xmin=500,
xmax=9500,
] 
\addplot[dotted,mark=x] table[x=PathsFound,y=time(ns)]{../Thesis/Experiment-DATA/CaseStudyRuntimeCplex.csv};
\addplot[solid,mark=x] table[x=PathsFound,y=time(ns)]{../Thesis/Experiment-DATA/CaseStudyRuntimeBFS.csv};
\end{axis}
\end{tikzpicture}%
\caption{Runtime of our implementation depending on the number of test cases. Left: depth first search. Right: breadth first search}
\label{fig:RuntimeExperimentsData}
\end{figure}
The runtime of our algorithm is not the only thing that grows exponentially with the maximum path length. Also the number of control flow paths in the activity diagram shorter than the maximum path length grows exponentially. We show this effect in Figure \ref{fig:RuntimeExperimentsSolvers}. The number of test cases grows exponentially with respect to almost the same basis as the runtime and the quotient of runtime and generated test cases grows polynomial. 
To illustrate that, we plotted the runtime of our algorithm against the number of test cases in Figure \ref{fig:RuntimeExperimentsData}. For the plot on the left we used the same data as for the LPsolve plot in Figure \ref{fig:RuntimeExperimentsSolvers}. The plot is logarithmic on both axis and we can see that the runtime grows not linearly with the number of test cases, but it grows with an exponent of $1.45$.\\
It would not produce useful test cases to use depth first search and no limit on the maximum path length but a limit on the test cases to find. All generated test cases would over and over share very long common sub--paths and other control flows would not be checked at all. Since this would not be desired in practice, we used the breadth first search explained in Section \ref{sec:pathsearchBFS} to evaluate the effect of the maximum amount of test cases on the runtime.\\
In Figure \ref{fig:RuntimeExperimentsData}, we plot on the right the runtime of our algorithm with breadth first search, early infeasible path elimination, and Cplex as solver. The dotted line shows a small section of the first plot where the previous data has been reused. As we can see breadth first search is considerably slower than depth first search. The reason for that is that breadth first search can not make such a good use of the warm start capabilities of the solvers as depth first search can. Details of the warm start capabilities have been explained in Section \ref{sec:AMPLWarmStartCapabilities}. In depth first search between two subsequent solver invocations usually only a small amount of the constraints change. For breadth first search it will happen several times during the infeasible path elimination that all constraints have changed between two subsequent calls to AMPL. Furthermore, we see that the generation of 9,000 test cases took only slightly longer than the generation of 8,000 test cases. We currently can not explain this strange effect.
\subsubsection{Boundary Value Analysis}
\label{sec:caseStudyBoundaryValues}
\begin{figure}
\begin{center}
\begin{tikzpicture}
\begin{axis}[
width=0.59\textwidth,
height=7cm,
%title={Influence of boundary value analysis},
legend style={at={(0.02,0.98)},anchor=north west},
ylabel={time $[s]$},
xlabel={maximum path length},
%ytick={1e8,1e10,1e12,1e14},
yticklabels={0,{1},{10},{100},{$10^3$},{$10^4$},{$10^5$}},
extra y ticks={3.6e12,2.592e14},
extra y tick labels={{1h},{3d}},
extra tick style={
        major grid style=black,
        tick align=outside,
        tick style=black
    },
ymajorgrids=true,
yminorgrids=true,
xmajorgrids=true,
xminorgrids=true,
ymode=log,
]
\addplot[dotted,mark=x] table[x=PATHSEARCH_MAX_PATHLENGTH,y=time(ns)]{../Thesis/Experiment-DATA/CaseStudyRuntimeBoundaryValues.csv};
\addlegendentry{with};
\addplot[dashed,mark=x] table[x=PATHSEARCH_MAX_PATHLENGTH,y=time(ns)]{../Thesis/Experiment-DATA/CaseStudyRuntimeNoBoundaryValues.csv};
\addlegendentry{without}
\end{axis}
\end{tikzpicture}%
\end{center}
\caption{Comparison of runtime with boundary value analysis and without boundary value analysis}
\label{fig:RuntimeBoundaryValue}
\end{figure}
Finally, we also analysed the impact of the boundary value analysis on the runtime of our implementation. As explained in Section \ref{sec:boundaryValueSelection}, an additional objective in the AMPL program has been added that enforces all initialisation values of the test case to be minimal with respect to the path constraints in the control flow path. In Figure \ref{fig:RuntimeBoundaryValue}, we show the runtime of our algorithm depending on the maximum path length. We use depth first search and LPsolve as solver. The runtime with boundary value analysis and the runtime without boundary value analysis are plotted. Obviously it does not make a difference at all for the runtime whether we generate values at a specific boundary of the feasible region or just any feasible points as test data.\\
This is plausible because the number of solver invocations where really a boundary value analysis is performed is small compared to the number of total solver calls. For example, for a maximum path length of 70 there are 1568 test cases. The solver performs the optimisation only for them. On the other hand, there are 35044 solver invocations in total including those for the infeasible path elimination and those that recognise an abstract test case as infeasible. They are performed just in the same way as without boundary value analysis. The simplex algorithm will first determine the feasibility and then optimise. Consequently, only $\frac{1}{22}$ of all solver invocations is actually performing some extra work. For larger maximum path lengths this fraction is declining. For this particular instance of the mixed--integer linear programming problem it is particularly easy for the simplex algorithm to find the boundaries since there are no interdependencies between the variables. Each variable in the objective function can just be set to its minimum and no branch--and--bound steps need to be performed.\\
We definitely recommend to use this feature for mixed integer linear programs in practice because it really comes at no cost, and one can use this feature to generate test data at two or more different boundaries of the feasible set and generate multiple test cases for one control flow path that check all path conditions for the control flow path.

\subsection{Summary and Recommendation}%
\label{sec:Recommendation}
\section{Outlook}%
\bibliographystyle{splncs}%
\bibliography{../Thesis/bibtex}%
\end{document}