\documentclass[runningheads,a4paper]{llncs}%
%\documentclass[runningheads,a4paper]{article}%
%
\usepackage{amssymb}%
\setcounter{tocdepth}{3}%
\usepackage{graphicx}%
\usepackage{listings}
\usepackage{lstlangampl}
\usepackage{algorithm}
\usepackage{algpseudocode}
%
\usepackage{url}%
\urldef{\mailsa}\path|{felix.kurth, schupp}@tu-harburg.de|%
\newcommand{\keywords}[1]{\par\addvspace\baselineskip%
\noindent\keywordname\enspace\ignorespaces#1}%
%
% My user defined inclues%
\usepackage{color} %Makes incscape pdf_tex work%
\usepackage[T1]{fontenc} % makes Guillemont available%
\newcommand{\UMLType}[1]{\textsf{\textit{#1}}} %
\newcommand{\TCGType}[1]{#1}%
\newcommand{\UMLReference}[1]{\textsf{\textit{#1}}} %
\newcommand{\AMPLCode}[1]{\texttt{#1}}
\newcommand{\OCLCode}[1]{\texttt{#1}}
\newcommand{\AMPLListing}[1]{\begin{lstlisting}[basicstyle=\ttfamily\scriptsize,language=ampl]{#1}\end{lstlisting}}
%
\begin{document}%
%
\mainmatter  % start of an individual contribution%
%
% first the title is needed%
\title{Automated Generation of Unit Tests from UML Activity Diagrams using the AMPL Interface for Constraint Solvers}%
%
% a short form should be given in case it is too long for the running head%
\titlerunning{Automated Generation of Unit Tests}%
%
% the name(s) of the author(s) follow(s) next%
%
% NB: Chinese authors should write their first names(s) in front of%
% their surnames. This ensures that the names appear correctly in%
% the running heads and the author index.%
%
\author{Felix Kurth%
% \thanks{Please note that the LNCS Editorial assumes that all authors have used%
% the western naming convention, with given names preceding surnames. This determines%
% the structure of the names in the running heads and the author index.}%
\and Sibylle Schupp}%
%
%\authorrunning{Lecture Notes in Computer Science: Authors' Instructions}%
% (feature abused for this document to repeat the title also on left hand pages)%
%
% the affiliations are given next; don't give your e-mail address%
% unless you accept that it will be published%
\institute{Hamburg University of Technology, Institute for Software Systems,\\%
Schwarzenbergstr. 95, 21073 Hamburg, Germany\\%
\mailsa\\%
\url{http://sts.tu-harburg.de}}%
%
%
% NB: a more complex sample for affiliations and the mapping to the%
% corresponding authors can be found in the file "llncs.dem"%
% (search for the string "\mainmatter" where a contribution starts).%
% "llncs.dem" accompanies the document class "llncs.cls".%
%
%
%\toctitle{Lecture Notes in Computer Science}%
%\tocauthor{Authors' Instructions}%
\maketitle%
%
\begin{abstract}%
The task of Model--Based Testing is to ensure that the implementation behaves as specified in its model. We present a method to generate test data from UML activity diagrams. Our method uses symbolic execution to collect embedded OCL constraints along a control--flow path and transforms them into `\textbf{A} \textbf{M}athematical \textbf{P}rogramming \textbf{L}anguage' (AMPL). We derive test data from the mathematical program using state--of--the--art constraint solvers. The generated tests will satisfy control--flow--based coverage criteria on the used models. We also use boundary value analysis for testing. A special focus is on allowing mixed integer non--linear programming as well as logical formulas in the collected OCL constraints. The presented method has been implemented in a demo Eclipse plug-in that generates fully automatically compilable C++ unit tests from activity diagrams.%
% The abstract should summarise the contents of the paper and should%
% contain at least 70 and at most 150 words. It should be written using the%
% \emph{abstract} environment.%
\keywords{Model-Based Testing, Activity Diagram, Constraint Solving, Symbolic Execution, Boundary Value Analysis, Eclipse Plug-In}%
\end{abstract}%
\section{Introduction}%
Model--Based Engineering is a recent technology in the domain of electrical and software engineering. 
%In Model--Based Engineering, the specification of a system is developed as a model. 
The Unified Modelling Language\textsuperscript{\texttrademark} (UML) is the quasi standard to build model--based specifications. A UML diagram can give a quick and intuitive overview of a system. At the same time, UML can be used as a formal modelling language to express details of the design and behaviour. The activity diagram is one of the behavioural diagrams specified in the UML. It can be used to describe a use case at the system level as well as to visualise the detailed control and data flow of a function. Activity diagrams also support hierarchical modelling whereby it is possible to start with a vague description of the intended use of a system and add more and more details until one models at the function level.\\%
Modelling is not an end unto itself. One way to profit from Model-Based Engineering is to automate other tasks in software development. One important task is testing. We want to generate test data fully automated from an activity diagram with embedded OCL constraints. The test model is a model of the relevant control--flows in the system under test (SUT). The embedded OCL constraints describe interdependencies between the variables and how variables change their value.\\
In this paper we present a transformation from an activity diagram into an `A Mathematical Programming Language' (AMPL) program. We symbolically execute control--flow paths in the activity diagram and encode each of them as AMPL program. The solution of the resulting AMPL program contains input values and corresponding oracle values that can be used to test the implementation. Since tests using test data at the bounds of path constraints have a higher probability to detect faults, we also use boundary value analysis. Depth--first search is used to find control--flow paths and we introduced \emph{early infeasible path elimination} within the depth--first search to reduce the runtime of our algorithm. The presented transformation is implemented as part of a master thesis \cite{Kurth2014AutomatedGen} in a proof--of--concept fully automated unit test generation tool. The tool is available as Eclipse plug-in \cite{PartegWebsite}.\\%
We will summarise Model--Based Testing approaches similar to ours in Section \ref{sec:LiteratureReview}. Definitions and a description of the expected test model is given in Section \ref{sec:TestModel}. 
An introduction to the AMPL system is given in Section \ref{sec:AMPL}. 
Section \ref{sec:Algorithm} will explain the core ideas of the proposed algorithm beginning with the transformation of a control--flow path into an AMPL program, then, explaining how boundary value analysis is done and, finally, how we can efficiently search for test scenarios. We provide a proof--of--concept tool and will report on a case study in Section \ref{sec:CaseStudy}. Finally, we give an outlook.%
\section{Literature Review}%
\label{sec:LiteratureReview}%
While it is very common to use state machines as the test model, less research is performed on generating tests from UML activity diagrams. Wang Linzhang et al. propose in \cite{Linzhang04GeneratingTestCasefromActivityGrayBoxMethod} a path--search--based method to find test scenarios in an activity diagram. They also claim to have implemented a proof--of--concept tool called UMLTGF, which, unfortunately, was unavailable for review. Another proposal using UML Activities as test model comes from Chen Minsong et al. \cite{mingsong2006automatic}. Their approach is to generate random executable unit tests for a Java implementation and match the execution traces of the randomly generated unit tests with the control--flow paths found in an activity diagram. They then select a subset from the test cases, which covers all simple paths in the test model.%
% They propose using an activity diagram to automate the selection of a subset from a set of randomly generated unit tests for a set of Java classes and methods.
\\%
Stephan Wei{\ss}leder and Dehla Sokenou presented a data--oriented approach to select test cases \cite{weissleder2008automatic}. They propose to use abstract interpretation to derive partitions of the domain of input values. They then propose to select values at the boundaries of the computed partitions as test data. %
In Stephan Wei{\ss}leders Ph.D Thesis \cite{ParTeG} we found the most detailed and complete collection of different model--structure and data--oriented coverage criteria. Furthermore, a formal definition of the coverage criteria is given. The source code of ParTeG, the proof--of--concept tool associated with this thesis, is freely available. It uses graph search in combination with abstract interpretation and a comprehensive framework allowing the user to steer which coverage criteria the generated test cases will adhere to.\\
Using OCL as input and trying to obtain test data by solving OCL constraints there have been several proposals on how exactly to find models that make an OCL formula true. Shaukat Ali et al. proposed in \cite{ali2011search} using evolutionary or genetic algorithms to search for potential solutions of OCL constraints. Matthias P. Krieger and Alexander Knapp proposed in \cite{krieger2008executingUnderspecifiedOCL} using a SAT solver to find instantiations of variables fulfilling OCL constraints. They suppose to transform OCL formulas into boolean formulas with bounded quantifiers and uninterpreted functions. Consequently, they use a model finder, based on a SAT solver, capable of handling those formulas to find assignments to the variables.\\%
In \cite{malburg2011combining} Jan Malburg and Gordon Fraser propose a hybrid approach. On the top level they use a genetic algorithm evolving a population of candidate test data. Internally, they provide guidance to the genetic algorithm by providing a special mutation operator performing dynamic symbolic execution. Also the white--box unit test tool PEX \cite{pex} from Microsoft\textsuperscript{\textregistered} research is based on dynamic symbolic execution. Both publications, \cite{malburg2011combining} and \cite{pex}, propose to execute the implementation with random input values and generate new input values by collecting all path conditions along the executed control--flow. Then they negate one of the path conditions and use a constraint solver to find a solution for the new constraint system. The generated solution yields new input data, which is guaranteed to take another control--flow path in the program.\\%
% \subsection{Overview}%
% \subsubsection{Symbolic Execution}
% In order to make UML activity diagrams executable for test data generation we will transform all relevant constraints embedded in the UML model into a mathematical program. Executing a certain control--flow path in the activity diagram means generating the corresponding mathematical program. The mathematical program will be stated in AMPL syntax. A mathematical program in AMPL consists of an AMPL model and AMPL data. One activity diagram will be transformed into one AMPL model and the currently executed control--flow path can be specified in the AMPL data.\\
% %In order to compute test data for the system under test we will use AMPL (\textbf{A} \textbf{M}athematical \textbf{P}rogramming \textbf{L}anguage). The activity diagram will be represented by arrays of variables and indexed collections of arithmetic constraints. In a data section for the model we can specify which control--flow path within the activity diagram we are interested in. From the computed solution to the mathematical program we obtain the test data for the unit tests. 
% When building the AMPL model from the activity diagram, we have to be careful that the semantics of the resulting AMPL model corresponds with the semantics the modeller originally had in mind. We support the user by automatically adding constraints that would be cumbersome to make explicit manually.
% \subsubsection{State--Of--The--Art Constraint Solver Implementations} 
% %We generate test data for a control--flow path in an activity diagram to be tested by having the corresponding AMPL program solved by a constraint solver. 
% A great advantage of a commonly used mathematical programming language is that industrial--strength solvers are available. The AMPL program corresponding to a possible control--flow path in the activity diagram will be solved with a state--of--the--art solver. Then we obtain test data from the results of the constraint solver. The generated test data includes possible input arguments for the C function that implements the activity diagram. Also, all expected return values as well as values for class properties before and after the execution of the activity diagram are included.\\
% A suitable solver needs to be selected depending on the problem formulation. Not every solver can solve every AMPL program, and not every AMPL program is an instance of an easy--to--solve problem. An overview of the problems that are considered throughout this thesis can be found in Section \ref{sec:Maths}.
% \subsubsection{Results}
% A practical result of this thesis is an Eclipse plug-in that automatically generates unit tests from activity diagrams. The plug-in comes with a set of example models. Each example is an instance of a different mathematical problem and thus needs an appropriate solver to be solved successfully. Moreover, we performed an industrial case study using a model of the PAX--Call system, which is part of an Airbus product. We added the missing OCL constraints and successfully generated test cases for the largest activity diagram within the model. Finally, we experimentally determined the scalability of the implementation.
% \section{Preliminaries}%
% \label{sec:Preliminaries}%
\section{Semantics of the Test Model}%
\label{sec:TestModel}%
% XXX potentially add figure MOF Metamodel of relevant UML Elements%
For the transformation into `A Mathematical Programming Language' (AMPL) presented in Section \ref{sec:AMPLTransformation} we need to clarify the semantics of the expected input model. Whenever we refer to a modelling element such as \UMLType{Activity} we print it in a special font. References and attributes defined in the UML as, for example, \UMLReference{name} or \UMLReference{ownedParameter} are printed in a special font as well. In this section, we first clarify which UML modelling elements we use and will then shortly recapitulate the Petri--Net semantics of activity diagrams (see \cite{UML23Superstructure}) and introduce the notion of a \emph{state}, which will be relevant for our algorithm.\\%
As test model we assume an activity diagram with \UMLType{Action}s, \UMLType{ControlNode}s, and \UMLType{ControlFlow}s modelling the control--flow of an \UMLType{Operation}. The \UMLType{Activity} is linked as \UMLReference{method} to its specifying \UMLType{Operation}. Each \UMLType{Action} can contain several %
%hold arbitrary many %
%\UMLType{Constraint} %
%modelling %
textual OCL constraints as \UMLReference{localPostcondition} and each \UMLType{ControlFlow} can hold a textual OCL constraint as %
%other elements %
%\UMLType{ValueSpecification}s in its 
\UMLReference{guard} reference. The textual OCL in the \UMLReference{guard} and \UMLReference{localPrecondition} will be parsed in the context of the specifying \UMLType{Operation}. That means the OCL constraints can access all \UMLReference{ownedAttribute}s %
%\UMLType{Property} elements %
of the \UMLType{Class} containing the specifying \UMLType{Operation}. Further, all \UMLReference{ownedParameter}s of the specifying \UMLType{Operation} can be referenced in the textual OCL. We interpret every \UMLType{Property} as variable that can change its value during the execution of an \UMLType{Action}. A \UMLType{Parameter} will be interpreted as a parameter that can not change its value during the execution of an \UMLType{Action}.\\%
%We keep the Petri--Net like semantics of activity diagrams in mind and take a closer look at how we execute a control--flow path in an activity diagram. 
When executing a control--flow path, we start with a token in the \UMLType{InitialNode}. We allow only one \UMLType{InitialNode} per \UMLType{Activity}. The token can move along an enabled \UMLType{ControlFlow}. A \UMLType{ControlFlow} is enabled when the OCL constraint in its \UMLReference{guard} evaluates to true. We say that an \UMLType{Action} is being executed when a token resides in the \UMLType{Action}.\\
We refer to an assignment of all variables and parameters as \emph{state}. While the token resides in the \UMLType{InitialNode} there is an initial state. After each execution of an \UMLType{Action} the current state might change according to the OCL constraints contained in the \UMLType{Action}'s \UMLReference{localPostcondition}. An OCL constraint contained as \UMLType{localPostcondition} can specify a relation between the current state and the previous state. Consequently, the states are interconnected with each other via the textual OCL constraints contained in \UMLReference{localPostcondition} references. The set of all relations contained in \UMLType{localPostcondition}s can be seen as state transition function. For a \UMLType{ControlFlow} to be enabled the OCL constraint in its \UMLReference{guard} has to evaluate to true with respect to the current state. OCL constraints contained in a \UMLReference{guard} can only specify a relation between the variables and parameters within a single state. It is not possible to access the value of a variable in the previous state within a \UMLReference{guard}.%
\subsection{AMPL and its Solvers}%
\label{sec:AMPL}
We use `A Mathematical Programming Language' (AMPL) by Robert Fourer \cite{AMPL} as a means to formalise the execution of a control--flow path in the test model. There is also a software that takes a program in the AMPL language and transforms it into a form that can be digested by constraint solvers. In this section, we will discuss the expressiveness of AMPL and introduce the solvers we have successfully used to generate test data.\\%In this subsection we will first mention the language elements of AMPL that we are using and then introduce the advantage of having AMPL as a common interface to different solvers suitable for distinct specializations of the constraint satisfaction problem.\\%
An AMPL program consists of two parts, the AMPL model and the AMPL data. In AMPL models we can declare parameters, sets, variables, and constraints. In the AMPL data we will give specific values for the parameters and sets. A suitable state--of--the--art solver can assign the variables such that all constraints are satisfied with the given parameters and sets.
\begin{table}%
\begin{center}%
\begin{tabular}{l r r r r r r r r}%
Solver                         & MILP       & NLP        & SMT        & MINLP\\%
\hline%
Cplex                          & \checkmark &            &            &\\%
LPsolve\cite{lpsolve}          & \checkmark &            &            &\\%
Gurobi                         &            & \checkmark &            &\\%
Minos                          &            & \checkmark &            &\\%
IlogCP\cite{ilogcp}            & \checkmark &            & \checkmark &\\%
GeCoDE\cite{gecode}            &            &            & \checkmark &\\%
Couenne\cite{Belotti09couenne} & \checkmark & \checkmark &            & \checkmark\\%
\hline%
\end{tabular}%
\end{center}%
\caption{List of solvers and problems they can solve.}%
\label{tab:Solvers}%
\end{table}\\%
In AMPL we can state linear constraints and non--linear constraints. Variables can be continuous or discrete; furthermore, AMPL provides logical operations. The AMPL system serves as a common interface to a variety of solvers. Depending on the constraint satisfaction problem encoded in the AMPL program a suitable solver can be selected to solve the problem. If all constraints are linear we use a solver that is specialized on mixed integer linear programming (MILP). If constraints are non--linear but convex and all variables are continuous we use a non--linear programming (NLP) solver. For problems with non--linear constraints and discrete as well as continuous variables we need a solver capable of solving mixed integer non--linear programming (MINLP). If logical operations are used in the constraints, a satisfiability modulo theories (SMT) solver supporting appropriate background theories is used. In Table \ref{tab:Solvers} we show a selection of solvers interfacing with AMPL. A checkmark in a cell means that we have successfully tested the solver in the row on the problem named in the column.%
\section{The Algorithm}%
\label{sec:Algorithm}%
In this section we explain the core ideas of the algorithm that is implemented in the tool available from \cite{PartegWebsite}. First, we demonstrate with a small example how the execution of a control--flow path can be formalised. Then we show how to acquire test data that is at the boundary of path constraints and, finally, we present an algorithm that searches for testable control--flow paths efficiently.%
\subsection{AMPL Transformation}%
\label{sec:AMPLTransformation}%
\begin{figure}%
\def\svgwidth{\textwidth}%
\graphicspath{{./pics/}}%
\input{./pics/AssignmentDecision.pdf_tex}%
\caption{A simple UML activity diagram}%
\label{fig:AssignmentDecision}%
\end{figure}%
An AMPL model encodes the relevant variables, parameters, and OCL constraints contained in an activity diagram. We call a sequence of \UMLReference{ControlFlow}s \emph{control--flow path}. For two subsequent \UMLType{ControlFlow}s A and B in a control--flow path the constraint A.target=B.source holds. A control--flow path is encoded in the AMPL data. The activity diagram in Figure \ref{fig:AssignmentDecision} will serve as an example.\\%
We model the execution of a control--flow path as a series of states. Each AMPL model has one parameter called \AMPLCode{pathlength} representing the number of \UMLType{Actions} on a control--flow path. The state always changes during the execution of an \UMLType{Action}, consequently, there is one initial state and one post state after each execution of an \UMLType{Action}. Since a variable can have a distinct value in each state, each variable will be modelled in AMPL as an array of variables with the length $\AMPLCode{pathlength}+1$. Parameters are constant and cannot change their value from one state to another and will, consequently, be represented by a single AMPL variable. Every variable and parameter has one out of three possible types: integer, real, and boolean; In AMPL we specify the domain of an AMPL variable correspondingly.\\%
The OCL constraints in Figure \ref{fig:AssignmentDecision} reference three different OCL variables. We assume $a$ and $returnValue$ to be parameters that are modelled as a single variable in AMPL and we assume $x$ to be a variable that is modelled as an array of variables. We further assume that the \UMLReference{type} of the modelling elements corresponding to the OCL variables $a$, ${returnValue}$, and $x$ is integer. Consequently, we generate the following AMPL code for them: %
\begin{lstlisting}[basicstyle=\ttfamily,language=ampl]
param pathlength;
var a : integer;
var returnValue : integer;
var x{0..pathlength} : integer;
\end{lstlisting}%
The underlying MOF Model--to--Text Transformation Language\cite{m2t.standard} (MOFM2T) template, generating AMPL code from a \UMLType{Parameter} or \UMLType{Property} is shown in Algorithm \ref{alg:m2tvariable}.
\begin{algorithm}
\begin{lstlisting}[numbers=left,escapeinside={@}{@},breaklines=true]
[@\bfseries{template}@ public VariableToAMPL(var : @\UMLType{TypedElement}@)]
  [@\bfseries{let}@ type : @\UMLType{PrimitiveType} = var.type@]
    var [var.name/] [@\bfseries{if}@ var.oclIsKindOf(@\UMLType{Property}@)] {0..pathlength} [/@\bfseries{if}@][Type2AMPL(type)/] :=1;
  [/@\bfseries{let}@]
[/@\bfseries{template}@]

[@\bfseries{template}@ public Type2AMPL(type : @\UMLType{PrimitiveType}@)]
  [@\bfseries{if}@ type.name = 'integer'] : integer >=-10000, <= 10000 [/@\bfseries{if}@]
  [@\bfseries{if}@ type.name = 'boolean'] in 0..1 [/@\bfseries{if}@]
  [@\bfseries{if}@ type.name = 'real'] >=-10000, <= 10000 [/@\bfseries{if}@]
[/@\bfseries{template}@]
\end{lstlisting}%
\caption{Model--to--text transformation from \UMLType{Property} or \UMLType{Parameter} to AMPL model}%
\label{alg:m2tvariable}%
\end{algorithm}\\%
During execution a \UMLType{ControlFlow}'s \UMLReference{guard} or an \UMLType{Action}'s \UMLReference{localPostcondition} is always evaluated with respect to the current state. The set of states in which an \UMLType{Action} or \UMLType{ControlFlow} is executed is called \emph{activation set}. There is one activation set for each \UMLType{ControlFlow} with an OCL \UMLReference{guard} and each \UMLType{Action} with OCL \UMLReference{localPostcondition}. % 
All OCL post--conditions and OCL guards are contained in the AMPL model as constraints, which can be switched on and off for each state. %
%
For each \UMLType{Action} and \UMLType{ControlFlow} the activation set is declared as a subset of $\left[0..\texttt{pathlength}\right]$ in the AMPL model. Each local post--condition of an \UMLType{Action} is transformed into an indexed collection of constraints over the activation set.\\
If the variable reference was marked with \verb=@pre= we are accessing the variable in the previous state and thus need to subtract one from the index; otherwise we access the variable at the index from the activation set. %
The transformation of guards works analogously to the transformation of local post--conditions.
%In cyclic activity diagrams there are paths that contain one control--flow several times. The activation set will then contain one entry for each state in which a token moves along the control--flow from the source node to the target node. Actions can be executed several times to move from one state to another, thus the corresponding activation set will then contain the index of the state after execution of the action for each execution. \\
The value of the parameter \texttt{pathlength} as well as the elements of each activation set will be specified in the AMPL data. This way, there is one AMPL model per activity diagram and any control--flow path within the activity diagram can be specified in the AMPL data.\\
%
%
To illustrate how the symbolic execution of a control--flow path in an activity diagram is done we consider again the activity diagram in Figure \ref{fig:AssignmentDecision}. Let us assume we want to generate test data to test the control--flow path printed in bold, which executes the Assignment and the Then \UMLType{Action}. We start at the \UMLType{InitialNode}, the current state is the initial state with the index $0$. In this state there are no constraints. When we reach the Assignment \UMLType{Action} our current state switches to $1$. Since there is a post--condition for Assignment we add 1 to the activation set of the Assignment. The next \UMLType{ControlFlow} has an OCL guard, consequently we add $1$ to its activation set. Further, we add $2$ to the activation set of the Then \UMLType{Action}.\\%
In AMPL syntax, the data specifying this path is:%
\begin{lstlisting}[basicstyle=\ttfamily,language=ampl]
param pathlength := 2;
set Assignment := 1;
set Cf_Then := 1;
set Then := 2;
\end{lstlisting}%
The transformation from a sequence of \UMLType{ControlFlow}s into a map of activation sets is given in Algorithm \ref{alg:ActivationSet}.%
\begin{algorithm}
\begin{algorithmic}[1]
\Require path := sequence of \UMLType{ControlFlow}s
\Ensure activationSets contains activation sets representing the given path
\State activationSets(element : \UMLType{NamedElement}) : Integer Set \Comment Mapping from an UML element to a set of integers. Initially all sets are empty.
\State i $\gets$ 0 \Comment index of the current state
\ForAll{cf : \UMLType{ControlFlow} $\in$ path}
\If{ cf.guard != null}
\State activationSet(cf).add(i)
\EndIf
\If{ cf.target.oclIsKindOf(\UMLType{Action}) }
\State i $\gets$ i+1 \Comment state changes
\State activationSet(cf.target).add(i)
\EndIf
\EndFor
\end{algorithmic}
\caption{Transformation from a control--flow path to a map of activation sets}
\label{alg:ActivationSet}
\end{algorithm}%
\subsection{Boundary Value Analysis}%
\label{sec:BoundaryValueAnalysis}%
Test data at the boundaries of the path constraints is more valuable than arbitrary test data causing the given control--flow path to be executed. We will refer to test data at the boundaries of path constraints also as \emph{boundary test data}. Up to now we have shown how we generate an AMPL program whose solutions can be used as test data for a given control--flow path. Now we want this test data to be at the boundary of certain path constraints. Therefore, we add a linear objective function to the AMPL model. When solving AMPL programs augmented by such an objective function three things can happen: either the solver generates boundary test data, or the solver reports that the problem is unbounded, or the solving time for the problem increases enormously and the solver exceeds its time limit. The first case is the good case. In the second case we can change the direction of the objective function and try again to hit a boundary. The last case is especially a problem of mixed integer non--linear programming solvers. It is not too hard to find a solution to a mixed integer non--linear program, if there are enough solutions, but finding a solution that is optimal with respect to an objective function is much harder. In fact the solvers will try to find the global optimum although also a locally optimal solution with respect to a linear objective function would be suitable as boundary test data. In such a case we can first use a global mixed integer non--linear programming solver to solve the original AMPL program. In a second step we add the linear objective function and use a local search algorithm using the solution generated before as starting point to find a solution at the boundary of the path constraints.
\subsection{Early Infeasible Path Elimination}%
\label{sec:InfeasiblePathElimination}%
To identify the control--flow paths to generate test data for we construct a \emph{path tree}. A path tree is a tree data structure consisting of path tree nodes. Each path tree node holds a reference to its parent path--tree node and a reference to a \UMLType{ControlFlow}. The root node of a path tree points to an \UMLReference{outgoing} \UMLType{ControlFlow} of the \UMLType{InitialNode}. Any path tree node is a representation of a control--flow path from the \UMLType{InitialNode} to the \UMLReference{target} of the \UMLType{ControlFlow} referenced by that path tree node. Any leaf path tree node points to a \UMLType{ControlFlow} that ends in an \UMLType{ActivityNode} with no \UMLReference{outgoing} \UMLType{ControlFlow}. We call the control--flow path represented by a leaf path tree node an \emph{abstract test case}.\\
Not every control--flow path within an activity diagram is a \emph{feasible path}. A control--flow path is a feasible path, if it is possible to find test data that causes this control--flow path to be executed. In other words, for an infeasible path the corresponding AMPL program will contain contradicting constraints, for example: $x_0\leq5; x_0\geq10$. It is quite obvious, that if a path tree node represents an infeasible path any of its children nodes will also represent an infeasible path. Since we are only interested in abstract test cases for which test data can be generated we do not want to generate path tree nodes representing infeasible paths.\\
We can check whether the control--flow path represented by a path tree node is feasible by transforming it into an AMPL program as described in Section \ref{sec:AMPLTransformation} and running a solver. If the solver reports a failure or infeasibility of a problem, we assume the control--flow path to be infeasible. The earlier during construction of the path tree a control--flow path is detected to be infeasible the larger is the portion of the path tree that will not be examined further. On the other hand, if we check for every single path tree node during construction whether it is feasible we will impose unnecessary work. We allow for a customised trade--off by introducing the parameter \emph{unchecked steps}.%
\begin{algorithm}
\begin{algorithmic}
\Require activity := A UML \UMLType{Activity} \\
MaxDepth := maximum path length for each control--flow path \\
MaxNoPaths := maximum amount of different control--flow paths to be found\\
UncheckedSteps := 
\Ensure abstractTestCases := set of at most MaxNoPaths abstract test cases consisting of at most MaxDepth \UMLType{ControlFlow}s each\\
\State abstractTestCases $\gets$ initially empty set of path tree nodes \Comment initialisation
\State stack $\gets$ initially empty stack of path tree nodes
\State push root path tree node to stack
\While{!queue.isEmpty() \textbf {and} abstractTestCases.size $\leq$ MaxNoPaths}
\State ptNode $\gets$ stack.pop() \Comment visit next path tree node from the queue
\If{ptNode.depth $\leq$ MaxDepth} \label{line:BFSifFeasible}\Comment search only up to MaxDepth
\For{cf : \UMLType{ControlFlow} $\in$ ptNode.controlFlow.target.outgoing}
\State stack.push(new PathTreeNode(cf, ptNode.depth + 1, ptNode)) \Comment Add successor nodes to queue
\EndFor
\EndIf
\If{ptNode.controlFlow.target.outgoing->size()=0} \Comment A final node has been found
\State abstractTestCases.add(ptNode)
\EndIf
\EndWhile
\end{algorithmic}
\caption{Depth--first search based algorithm with early infeasible path elimination}
\label{alg:BreadthFirstSearch}
\end{algorithm}%
\section{Results}%
\subsection{Proof--of--Concept Tool}%
\label{sec:EclipsePlugIn}%
\subsection{Case Study}%
\label{sec:CaseStudy}
\section{Outlook}%
\bibliographystyle{splncs}%
\bibliography{../Thesis/bibtex}%
\end{document}